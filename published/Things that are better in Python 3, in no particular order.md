# Things that are better in Python 3, in no particular order

There's a big disclaimer here, which is that I still use Python 2 for my personal projects (and work, but that's less in my control). However, I've bumped up against several problems with Python 2 that have since been fixed in Python 3. The title of this post is a lie--these are organized by decreasing annoyance of the Python 2 problems.

* Exception chaining -- Python 2 exceptions swallow previously incurred exceptions, Python 3 tracks exception chains. See [PEP 3134](http://legacy.python.org/dev/peps/pep-3134/). I encounter this one frequently at work in our API tests, where the more recent "oh noes the server returned a 500!" trample the more informative "you're trying to friend...yourself? wat??" or similar errors that occur in the API endpoints themselves.
* No scope leakage from comprehensions -- in Python 2, variables defined inside list comprehensions persist outside the comprehension. In Python 3, they very rightly don't. I probably shouldn't be in-comprehension variables the same names as out-of-comprehension variables, but I didn't expect them to leak out, in the same way I don't expect local variables to leak into the global scope.
* Function arguments -- in Python 2, you can't call a function with a keyword argument *and* an arbitrary number of position arguments. In Python 3 you can, like this: `myfunction(*many_args, some_keyword=True)`. I'd do the same thing in Python 2 by splatting both args and kwargs and explicitly checking for `some_keyword` in the kwargs. It's way more annoying that way. Furthermore, the ability for keyword arguments to follow a `*` or varargs argument means that you can enforce certain args to be called by keyword only instead of position. For the function defined like so `def myfunction(arg1, arg2, *, some_keyword=True): ...`, any and all positional arguments after the first two will go into the unnamed vararg, and the only way to define `some_keyword` is to define it as a keyword argument. See [PEP 3102](https://www.python.org/dev/peps/pep-3102/).
* Returning to exceptions, in Python 3 you can no longer raise a class, you have to raise an instance of a class. Variable syntax can be difficult for people trying to learn a language, so simplifying the syntax of raise is a big win!
* Also in the context of simplifying syntax, I think that `print` probably will make more sense to new Pythonistas as a function than as a statement.